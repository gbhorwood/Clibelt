<?php

/**
 * Rate of speed of spinners and progress bars.
 * values given in miliseconds for usleep() between frame updates of animation
 */
define('DELAY_SLOW', 7500000);
define('DELAY_MED', 300000);
define('DELAY_FAST', 150000);
define('DELAY_VERY_FAST', 50000);

/**
 * Constants to define animation to use when running code with background()
 */
define('SPIN', 1); // ASCII rotating spinner
define('PROGRESS', 2); // Progress bar of #'s left to right


/**
 * Convenience defines of meta characters
 */
define('BACKSPACE', chr(8));
define('ESC', "\033"); // for use with ANSI codes

/**
 * ANSI color codes for output styling. Background colors are calculated from these foreground codes.
 */
define('BLACK', '30');
define('RED', '31');
define('GREEN', '32');
define('YELLOW', '33');
define('BLUE', '34');
define('MAGENTA', '35');
define('CYAN', '36');
define('WHITE', '37');

/**
 * ANSI styling codes.
 */
define('NORMAL', '0');
define('BOLD', '1');
define('ITALIC', '3'); // limite terminal support. ymmv.
define('UNDERLINE', '4');
define('STRIKETHROUGH', '9');

/**
 * Convenience ANSI codes
 */
define('CLOSE_ANSI', ESC."[0m"); // termination code to revert to default styling
define('BOLD_ANSI', ESC."[1m"); //
define('GREEN_ANSI', ESC."[32m"); //
define('RED_ANSI', ESC."[31m"); //

/**
 * Colorized output tags for PSR-2/RFC-5424 levels.
 */
define('OK', "[".ESC."[".GREEN."mOK".CLOSE_ANSI."] "); // non-standard
define('DEBUG', "[".ESC."[".YELLOW."mDEBUG".CLOSE_ANSI."] ");
define('INFO', "[".ESC."[".YELLOW."mINFO".CLOSE_ANSI."] ");
define('NOTICE', "[".ESC."[".YELLOW."mNOTICE".CLOSE_ANSI."] ");
define('WARNING', "[".ESC."[".YELLOW."mWARNING".CLOSE_ANSI."] ");
define('ERROR', "[".ESC."[".RED."mERROR".CLOSE_ANSI."] ");
define('CRITICAL', "[".ESC."[".RED."mCRITICAL".CLOSE_ANSI."] ");
define('ALERT', "[".ESC."[".RED."mALERT".CLOSE_ANSI."] ");
define('EMERGENCY', "[".ESC."[".RED."mEMERGENCY".CLOSE_ANSI."] ");

/**
 * serialized array of levels used to validate user-supplied level constants in write()
 */
define('VALID_LEVELS', serialize(array(
    OK,
    DEBUG,
    INFO,
    NOTICE,
    WARNING,
    ERROR,
    CRITICAL,
    ALERT,
    EMERGENCY, )));

define('LEFT', 0);
define('RIGHT', 1);
define('CENTER', 2);

/**
 * Clibelt
 *
 * @author gbh
 *
 * needs: php-curl
 * needs: stty
 * may need: ANSI
 *
 * @todo preflight
 * @todo writeLockFile()
 * @todo testLockFile()
 * @todo deleteLockFile()
 * @todo help() maybe build list of cli args to auto output
 * @todo handle arguments, maybe ie php commando
 * @todo banner() // printout text as a banner
 * @todo modify box for too narrow window, ie wrapping
 */
class Clibelt
{
    /**
     * Array holding the last error generated by Clibelt
     */
    private $lastError = array(
        "code" => null,
        "func" => null,
        "desc" => null, );

    /**
     * Count of lines of last output. Used by erase()
     */
    private $lastPrintLineCount = null;

    /**
     * The text of the last user input
     */
    private $lastInput = null;

    /**
     * @brief Gets the lastError thrown by Clibelt.
     *
     * Some methods in Clibelt fail by returning false and setting the lastError array. This allows
     * the script author to address the error and continue execution if desired.
     *
     * The array returned has three elements:
     *  * code: The numerical code of the error
     *  * func: The function that threw the error, from __FUNCTION__
     *  * desc: A short description of the error
     *
     * @return array
     */
    public function getLastError()
    {
        return $this->lastError;
    } // getLastError


    /**
     * @brief Gets the last input provided by the script user
     *
     * The key hit for calls to anyKey() are never stored here.
     *
     * @return String
     */
    public function getLastInput()
    {
        return $this->lastInput;
    } // getLastInput

    ##
    # Methods to read input piped in

    /**
     * @brief Returns the content of data piped in on stdin as a string
     *
     * @return String
     */
    public function readStdin()
    {
        $returnStdin = null;
        while ($line = fgets(STDIN)) {
            $returnStdin .= $line;
        }

        return (string) $returnStdin;
    } // readStdin


    /**
     * @brief Returns an iteratable stream of data piped in on stdin
     *
     * The stream returned from this method can be iterated over using foreach()
     * @code
     * foreach($cli->readStdinStream() as $list){
     *     ... do something with $list ...
     * }
     * @endcode
     *
     * @return Stream
     */
    public function readStdinStream()
    {
        while ($line = fgets(STDIN)) {
            yield $line;
        }
    } // readStdinStream

    ##
    # Methods to read user supplied input

    /**
     * @brief Pauses script execution until the user hits any key.
     *
     * An optional custom prompt can by supplied.
     *
     * @param $prompt Optional display prompt. If none provided, default is "Hit any key to continue: "
     * @return void
     */
    public function anyKey($prompt = null)
    {
        if (!$prompt) {
            $prompt = "Hit any key to continue: ";
        }
        readline_callback_handler_install($prompt, function () { });
        while (true) {
            $r = array(STDIN);
            $w = null;
            $e = null;
            $n = stream_select($r, $w, $e, null);
            if ($n && in_array(STDIN, $r)) {
                $c = stream_get_contents(STDIN, 1);
                fwrite(STDOUT, PHP_EOL);
                break;
            }
        }
    } // anyKey


    /**
     * @brief Convenience method wrapping promptChoice() to offer yes/no choice as [y,n]
     *
     * @param $prompt The optional string to display as a prompt to the user. Default "Choose 'yes' or 'no'"
     * @param $default Optional. Either 'y' or 'n'. The value to return if the user selects an invalid option or hits <cr>
     * @return String. Either 'y' or 'n'. Lowercase.
     */
    public function promptChoiceYn($prompt = "Choose 'yes' or 'no'", $default = null)
    {
        $default = strtolower($default);
        if ($default && !in_array($default, ["y", "n"])) {
            $default = null;
        }

        return $this->promptChoice($prompt, ["y", "n"], $default);
    } // promptChoiceYn


    /**
     * @brief Prompts the user to choose from a list of char values and returns the selection.
     *
     * This method provides a simple way for the script user to choose from a list of provided, single char, options.
     * The most common example would be yes/no choice presented as [y,n], but any list of characters and any prompt text
     * can be used. [y,n] is the default behaviour.
     *
     * A default option value can be set. If the script user makes a selection that is not in the list of options
     * or simply hits <cr>, and a default value is set, the default value is returned.
     *
     * If a default value is set, it is indicated both by being bolded in the displayed options list and by displayed in the
     * (Default:) part of the prompt.
     *
     * Options are case sensitive, ie an option list of [F,f] is valid.
     *
     * If no default value is set and the script user chooses and invalid option, the prompt is displayed again and will be
     * continued to be dispalyed until a valid option is selected.
     *
     * @param $prompt The string to display as a prompt to the user. Default "Choose one"
     * @param $options An array of chars representing the options. Deafault ["y","n"]
     * @param $default A char representing the default option if the user selects something not in the $options array. Default null.
     * @return String The value selected by the user as a single char
     * @note Only single chars are used as options and selections
     */
    public function promptChoice($prompt = "Choose one", $options = array("y", "n"), $default = null)
    {
        /**
         * The options[] argument is forced to an array of chars. If an array of strings is passed only the
         * the first letter is used. Since this method takes keystroke input without requiring a <cr>, it by
         * necessity can only work with single chars.
         */
        $testOptions = array_map(function ($option) {
                return $option[0];
            },
            $options);

        /**
         * A string of the options is appended to the prompt, with the default option in bold
         * (if the terminal supports it).
         */
        $defaults = array_fill(0, count($options), $default);
        $displayOptions = implode(",", array_map(function ($option, $default) {
                if ($option[0] == $default[0]) {
                    return BOLD_ANSI.$option[0].CLOSE_ANSI;
                }

                return $option[0];
            },
            $options,
            $defaults));

        /**
         * The prompt displays the list of options as well as the default option, if it is set, in brackets afterwards
         */
        $displayPrompt =  $prompt." [".$displayOptions."]";
        if ($default) {
            $displayPrompt .= "(Default $default)";
        }
        $displayPrompt .= ": ";

        /**
         * Direct read from STDIN with readline_callback_handler_install() is used to read user keystroke without
         * requiring them to hit <cr>
         */
        fwrite(STDOUT, $displayPrompt); // direct output used for prompt to preserve ANSI encoding for bold
        readline_callback_handler_install("", function () {});
        while (true) {
            $r = array(STDIN);
            $w = null;
            $e = null;
            $n = stream_select($r, $w, $e, null);
            if ($n && in_array(STDIN, $r)) {
                // read the user choice from STDIN
                $userChoice = stream_get_contents(STDIN, 1);

                // selection not in list, use the default if one has been set
                if ($default && !in_array($userChoice, $testOptions)) {
                    $userChoice = $default;
                    break; // usable input, break from loop
                }

                // selection is in list of options
                elseif (in_array($userChoice, $testOptions)) {
                    break; // usable input, break from loop
                }

                // bad selection, reprint prompt and continue with the loop
                else {
                    if ($userChoice != PHP_EOL) {
                        fwrite(STDOUT, $userChoice); // echo back user's keystroke so they can see their invalid choice
                    }
                    fwrite(STDOUT, PHP_EOL.$displayPrompt);
                }
            }
        }
        print PHP_EOL;

        // log the user choice in lastInput so it can be retrieved after the return event
        $this->lastInput = $userChoice;

        // The user input is returned as a char
        return $userChoice;
    } // promptChoice


    /**
     * @brief Reads one line of user input and returns it
     *
     * This method reads one line only. User must hit RETURN to submit.
     *
     * The text entered by the user is returned by this method. It can also be accessed by calling
     * getLastInput(). The getLastInput method only returns the most recent user-input.
     *
     * Validation of the user-supplied text is the responsibility of the script author.
     * This can be done with a test in while() loop, eg
     *
     * @code
     *  // assign user input to variable and test it's an integer
     *  while($userInput = filter_var($cli->read("please enter an integer"), FILTER_VALIDATE_INT) === false) {
     *      $cli->clearLine(); // clears user's input so they can start again
     *      $cli->printout("must be an integer...",ERROR); // display error message
     *  }
     *  $cli->printout("user entered ".$userInput); // here's the good input
     *
     *  // you can stack more than one validation in a do/while loop like so
     *  do {
     *      $userInput = $cli->read("enter between 5 and 10 chars");
     *
     *      // error on first validation fail
     *      if(strlen($userInput) < 5) {
     *          $cli->clearLine();
     *          $cli->printout("too short", ERROR);
     *      }
     *
     *      // error on second validation fail
     *      if(strlen($userInput) > 10) {
     *          $cli->clearLine();
     *          $cli->printout("too long", ERROR);
     *      }
     *  }
     *  // any validation fail starts the loop again
     *  while(strlen($userInput) < 5 || strlen($userInput) > 10);
     * @endcode
     *
     * @param $prompt String. The prompt to display to the user.
     * @return Mixed
     */
    public function read($prompt)
    {
        $this->printout($prompt.":");

        $userInput = trim(fgets(STDIN));
        // log the user choice in lastInput so it can be retrieved after the return event
        $this->lastInput = $userInput;

        return $userInput;
    } // read

    ##
    # Methods to do formatted output

    /**
     * @brief Writes string to STDOUT with optional ANSI formatting
     *
     * This is used instead of the print() or echo() commands as cli applications differentiate
     * output and error by stream.
     *
     * Exmples:
     *
     * @code
     *
     *  $cli->printout("this is ok", OK); // [OK] this is ok
     *  $cli->printout("warning here", WARNING); // [WARNING] this is ok
     *  $cli->printout("I am white text on a red background", null, WHITE, RED);
     *  $cli->printout("I am green text underlined", null, GREEN, UNDERLINE);
     *
     * @endcode
     *
     * @param $text String. The string to write to the stream
     * @param $level Pre-defined constant. Optional PSR-2 level to tag the output with. Valid constants to use for $level are:
     *      * OK
     *      * DEBUG
     *      * INFO
     *      * NOTICE
     *      * WARNING
     *      * ERROR
     *      * CRITICAL
     *      * ALERT
     *      * EMERGENCY
     * @param $foreground Pre-defined constant. Optional foreground color of text. Valid constants for $foreground are:
     *      * BLACK
     *      * RED
     *      * GREEN
     *      * YELLOW
     *      * BLUE
     *      * MAGENTA
     *      * CYAN
     *      * WHITE
     * @param $background Pre-defined constant. Optional background color or font style. Valid constants for $background are:
     *      * NORMAL
     *      * BOLD
     *      * ITALIC
     *      * UNDERLINE
     *      * STRIKETHROUGH
     *      * BLACK
     *      * RED
     *      * GREEN
     *      * YELLOW
     *      * BLUE
     *      * MAGENTA
     *      * CYAN
     *      * WHITE
     * @param $alignment Pre-defined constant. Optional alignment for text. Default is left. Valid constant is CENTER
     * @return void
     */
    public function printout($text, $level = null, $foreground = null, $background = null, $alignment = null)
    {
        $this->write($text, STDOUT, $level, $foreground, $background, $alignment);
    } // printout


    /**
     * @brief Writes string to STDERR with option ANSI formatting
     *
     * This is used instead of the print() or echo() commands as cli applications differentiate
     * output and error by stream.
     *
     * @param $text String. The string to write to the stream
     * @param $level Pre-defined constant. Optional PSR-2 level to tag the output with. Valid constants to use for $level are:
     *      * OK
     *      * DEBUG
     *      * INFO
     *      * NOTICE
     *      * WARNING
     *      * ERROR
     *      * CRITICAL
     *      * ALERT
     *      * EMERGENCY
     * @param $foreground Pre-defined constant. Optional foreground color of text. Valid constants for $foreground are:
     *      * BLACK
     *      * RED
     *      * GREEN
     *      * YELLOW
     *      * BLUE
     *      * MAGENTA
     *      * CYAN
     *      * WHITE
     * @param $background Pre-defined constant. Optional background color or font style. Valid constants for $background are:
     *      * NORMAL
     *      * BOLD
     *      * ITALIC
     *      * UNDERLINE
     *      * STRIKETHROUGH
     *      * BLACK
     *      * RED
     *      * GREEN
     *      * YELLOW
     *      * BLUE
     *      * MAGENTA
     *      * CYAN
     *      * WHITE
     * @param $alignment Pre-defined constant. Optional alignment for text. Default is left. Valid constant is CENTER
     * @return void
     */
    public function printerr($text, $level = null, $foreground = null, $background = null, $alignment = null)
    {
        $this->write($text, STDERR, $level, $foreground, $background, $alignment);
    } // printerr


    /**
     * @brief Outputs the provided text in a box bordered by hashes
     *
     * The box is bordered by # chars, with an inner left and right margin of 4 spaces.
     *
     * The box can be styled using the color and alignment constants as accepted by printout()
     * and printerr().
     *
     * Box is aligned centre by default.
     * @param $text. String.
     * @param $foreground. Pre-defined constant. A color constant as used in printout()
     * @param $background. Pre-defined constant. A color constant as used in printout()
     * @param $alignment. Pre-defined constant. An alignment constant as used in printout()
     * @return void
     */
    public function box($text, $foreground = null, $background = null, $alignment = CENTER)
    {
        /**
 * @todo make settable by arg
 */
        // inner left and right margin, in spaces
        $boxMargin = 4;

        // get the length of the longest line if there are more than one.
        // this is used to determine the overall width of the box and pad lines for centreing
        $lengthOfLongestLine = $this->getLengthOfLongestLine($text);

        // construct an array of all the lines of the box, excluding the top and bottom bars
        $box = array_map(
            function ($longext, $margin, $line) {
                $boxLine = "#";

                for ($i = 0;$i<$margin;$i++) {
                    $boxLine .= " ";
                }

                for ($i = 0;$i<ceil(($longext-$this->strlenAnsiSafe($line))/2);$i++) {
                    $boxLine .= " ";
                }
                $boxLine .= $line;

                for ($i = 0;$i<floor(($longext-$this->strlenAnsiSafe($line))/2);$i++) {
                    $boxLine .= " ";
                }

                for ($i = 0;$i<$margin;$i++) {
                    $boxLine .= " ";
                }

                $boxLine .= "#";

                return $boxLine;
            },
            array_fill(0, count(explode(PHP_EOL, $text)), $lengthOfLongestLine),
            array_fill(0, count(explode(PHP_EOL, $text)), $boxMargin),
            explode(PHP_EOL, $text));

            // print top bar of box
            $this->write(implode("", array(str_pad("", $lengthOfLongestLine+($boxMargin *2)+2, "#"))),
             STDOUT, null, $foreground, $background, $alignment);

            // print contents of box
            while (list(, $line) = each($box)) {
                $this->write($line, STDOUT, null, $foreground, $background, $alignment);
            }

            // print bottom bar of box
            $this->write(implode("", array(str_pad("", $lengthOfLongestLine+($boxMargin *2)+2, "#"))),
             STDOUT, null, $foreground, $background, $alignment);

            // override lastPrintLineCount for erase()
            $this->lastPrintLineCount = count($box)+2;
    } // box


    /**
     *
     *
     */
    public function menuDynamic($description, $prompt, $options, $innerAlign, $outerAlign, $highlightColour, $foregroundColour, $backgroundColour)
    {
        // hightlight the first option in the menu to start
        $highLightIndex = 0;
        // retrieve the key by the index
        $highLightKey = array_keys($options)[$highLightIndex];

        // draw the menu
        $this->printoutMenuBox($description, $options, $highLightKey, $innerAlign, $outerAlign, $highlightColour, $foregroundColour, $backgroundColour);

        // loop awaiting user input
        while (true) {
            // get key down event from user
            $userChoice = $this->getKeyDown();

            // scroll down
            // 66 down arrow
            // 9 tab
            if (ord($userChoice) == 66 || ord($userChoice) == 9) {
                // delete ouput of menu
                $this->erase();

                // update the menu to highlight the next option
                if ($highLightIndex < count($options)-1) {
                    $highLightIndex++;
                }
                // wrap back to top
                else {
                    $highLightIndex = 0;
                }

                // draw the new menu
                $this->printoutMenuBox($description, $options, array_keys($options)[$highLightIndex], $innerAlign, $outerAlign, $highlightColour, $foregroundColour, $backgroundColour);
            }

            // scroll up
            // 65 up arrow
            if (ord($userChoice) == 65) {
                // delete output of menu
                $this->erase();

                // update the menu to highlight previous option
                // wrap back to bottom
                if ($highLightIndex == 0) {
                    $highLightIndex = count($options)-1;
                } else {
                    $highLightIndex--;
                }

                // draw the new menu
                $this->printoutMenuBox($description, $options, array_keys($options)[$highLightIndex], $innerAlign, $outerAlign, $highlightColour, $foregroundColour, $backgroundColour);
            }

            // select and return current key
            // 10 return
            if (ord($userChoice) == 10) {
                $returnVal = array_keys($options)[$highLightIndex];
                break;
            }

            // key selection of option
            // if pressed key is the char of an option key select and return
            if (in_array($userChoice, array_keys($options))) {
                $returnVal = $userChoice;
                break;
            }
        } // while true

        // return selected key
        return $returnVal;
    } // menuDynamic


    /**
     * @brief Erases the output of the last call to either printout() or printerr()
     *
     * Only erases the last output, to either STDOUT or STDERR. If this method is called more than once successively
     * the subsequent calls will do nothing.
     * @return void
     * @note This method relies on cursor control. If either stream's output is being directed elsewhere, behaviour may be affected.
     */
    public function erase()
    {
        for ($i = 0;$i<$this->lastPrintLineCount;$i++) {
            fwrite(STDOUT,  "\033[F");  // move up one line
            fwrite(STDOUT,  "\033[2K"); // erase line
        }
        $this->lastPrintLineCount = null;
    } // erase


    /**
     * @brief Clears the last line of output
     *
     * @return void
     * @note This method relies on cursor control. If either stream's output is being directed elsewhere, behaviour may be affected.
     */
    public function clearLine()
    {
        fwrite(STDOUT,  "\033[F");  // move up one line
        fwrite(STDOUT,  "\033[2K"); // erase line
        $this->lastPrintLineCount = null;
    }

    /**
     * @brief Clears screen and homes cursor
     *
     * @return void
     */
    public function clear()
    {
        fwrite(STDOUT,  "\033[2J");     // ANSI to clear screen and home cursor
        fwrite(STDOUT,  "\033[0;0f");   // ANSI to move cursor to top left position
        $this->lastPrintLineCount = null;
    }

    ##
    # Methods to run code in background processes

    /**
     * @brief Runs executable PHP code in the background with an optional progress animation
     *
     * @param $function Either a callable or string containing valid PHP
     * @param $args Optional array of arguments for callable
     * @param $progressType The optional type of animation to display. One of SPIN or PROGRESS
     * @param $delay The speed at which the optional animation runs. One of DELAY_SLOW, DELAY_MED, DELAY_FAST or DELAY_VERY_FAST
     * @return mixed
     */
    public function background($function, $args, $progressType = SPIN, $delay = DELAY_MED)
    {
        // args may be sent as either an array of args, ie for call_user_func_array(), a string containg the value of
        // one arg, or null. Prepare args into an array for usage.
        $args = $this->prepArgs($args);

        /**
         * If code passed to background is not executable, error.
         * Sets lastError to 6 on failure and returns false.
         */
        if (!is_callable($function) && !is_string($function)) {
            $this->lastError["code"] = 6;
            $this->lastError["func"] = __FUNCTION__;
            $this->lastError["desc"] = "Invalid code for background operation";

            return false;
        }

        /**
         * Process fork is attempted.
         */
        $pid = pcntl_fork();

        /**
         * If a child process could not be spawned, die.
         */
        if ($pid == -1) {
            die("Could not spawn child process");
        }

        /**
         * Code execution is done in the child process
         */
        if ($pid) {
            // a callable function is passed
            if (is_callable($function)) {
                $returnedVal = call_user_func_array($function, $args);
            }

            // a string of PHP code is passed
            elseif (is_string($this->function)) {
                $returnedVal = eval($function);
            }
        }

        /**
         * Progress display is done in the parent process
         */
        else {
            if ($progressType == PROGRESS) {
                $this->progress($delay);
            } elseif ($progressType == SPIN) {
                $this->spin($delay);
            }
        }

        /**
         * at end of execution, SIGKILL the progress animation
         */
        posix_kill($pid, SIGKILL);

        print PHP_EOL;

        return $returnedVal;
    } // background


    /**
     * @brief A somewhat safe file copy method with option update animation.
     *
     * Animation is based on file size of destination file and is moderatley accurate.
     *
     * Errors in copying are stored in this objects internal lastError array. On error, this method
     * returns false, otherwise true.
     *
     * Unhandled errors in file copy are an annoyance in command line scripts. This method attempts to provide
     * ways for the script author to catch copy errors and handle them. The last error can be retrieved
     * with `getLastError()`
     *
     * The error codes that can be set in lastError are:
     *   * 1 = Source file does not exist
     *   * 2 = Source file is not readable
     *   * 3 = Destination directory does not exist
     *   * 4 = Destination directory is not writeable
     *   * 5 = Insufficient disk space
     *
     * Usage example:
     * @code
     * $cli = new Clibelt();
     * $copyCheck = $cli->safeCopy("/path/to/souce/file", "/path/to/destination/file");
     * if (!$copyCheck) {
     *     $copyError = $cli->getLastError();
     *     // handle or log error accordingly.
     *     // read below for error codes.
     * }
     * @endcode
     *
     * @param $sourceFile Path of file to copy
     * @param $destFile. String. Path to the file or directory for the destination of the copied file.
     * If a directory is provided, the destination file is given the same name as it has in the source file path.
     * @return String. The path of the newly-copied file or boolean false on error
     * @note spawns child process
     * @note Errors generated while preflighting the copy are stored in lastError
     */
    public function safeCopy($sourceFile, $destFile)
    {
        // the destination file may be a directory. if that is the case the desired behaviour is to use the filename
        // from the source file path.
        if (is_dir($destFile)) {
            $destFile .= "/".basename($sourceFile);

            // the directory path passed may or may not have been terminated with a /. if it was, we will have
            // a double / in the path. remove it.
            $destFile = preg_replace("/\/\//", "/", $destFile);
        }

        // tests the source file exists.
        // Sets lastError to 1 on failure and returns false.
        if (!@file_exists($sourceFile)) {
            $this->lastError["code"] = 1;
            $this->lastError["func"] = __FUNCTION__;
            $this->lastError["desc"] = "Source file $sourceFile does not exist";

            return false;
        }

        // tests the source file is readable.
        // Sets lastError to 2 on failure and returns false.
        if (!@is_readable($sourceFile)) {
            $this->lastError["code"] = 2;
            $this->lastError["func"] = __FUNCTION__;
            $this->lastError["desc"] = "Source file $sourceFile is not readable";

            return false;
        }

        // tests the destination directory exists.
        // Sets lastError to 3 on failure and returns false.
        if (!@file_exists(dirname($destFile))) {
            $this->lastError["code"] = 3;
            $this->lastError["func"] = __FUNCTION__;
            $this->lastError["desc"] = "Destination directory ".dirname($destFile)." does not exist";

            return false;
        }

        // tests the destination directory is writeable.
        // Sets lastError to 4 on failure and returns false.
        if (!@is_writeable(dirname($destFile))) {
            $this->lastError["code"] = 4;
            $this->lastError["func"] = __FUNCTION__;
            $this->lastError["desc"] = "Destination directory ".dirname($destFile)." is not writeable";

            return false;
        }

        // tests is sufficient disk space for the operation.
        // Sets lastError to 5 on failure and returns false.
        if (disk_free_space(dirname($destFile)) <= filesize($sourceFile)) {
            $this->lastError["code"] = 5;
            $this->lastError["func"] = __FUNCTION__;
            $this->lastError["desc"] = "Insufficient disk space for operation";

            return false;
        }

        // lastError is available through getLastError().

        // Process fork is attempted.
        $pid = pcntl_fork();

        // If a child process could not be spawned, die.
        if ($pid == -1) {
            die("Could not spawn child process");
        }

        // child process: Progress animation
        if ($pid) {
            $this->progressFilesizeTrack($destFile, filesize($sourceFile));
        }

        // parent processes: file copy
        else {
            copy($sourceFile, $destFile);
        }

        // at end of copy(), SIGKILL the progress animation
        posix_kill($pid, SIGKILL);

        // convenience message for script user
        fwrite(STDOUT, " done".PHP_EOL);

        return $destFile;
    } // safeCopy


    /**
     * @brief A somewhat safe file download method with a progress animation.
     *
     * Animation is based on file size of destination file and is moderatley accurate.
     *
     * Errors in downloading are stored in this objects internal lastError array. On error, this method
     * returns false, otherwise the path to the newly-downloaded file.
     *
     * Unhandled errors in file download are an annoyance in command line scripts. This method attempts to provide
     * ways for the script author to catch copy errors and handle them. The last error can be retrieved
     * with `getLastError()`
     *
     * The error codes that can be set in lastError are:
     *   * 3 = Destination directory does not exist
     *   * 4 = Destination directory is not writeable
     *   * 5 = Insufficient disk space
     *   * 7 = Error getting file data from url
     *   * 8 = Download error
     *
     * Usage example:
     * @code
     * $cli = new Clibelt();
     * $downloadCheck = $cli->download("http://example.com/file.tar", "/path/to/destination/file.tar");
     * if (!$downloadCheck) {
     *     $downloadError = $cli->getLastError();
     *     // handle or log error accordingly.
     *     // read below for error codes.
     * }
     * @endcode
     *
     * @param $url. String. The url of the file to download
     * @param $destFile. String. Path to the file or directory for the destination of the downloaded file.
     * If a directory is provided, the destination file is given the same name as it has in the url.
     * @return String. The path of the newly-downloaded file or boolean false on error
     * @note spawns child process
     * @note Errors generated while preflighting the copy are stored in lastError
     * @note test with http://ipv4.download.thinkbroadband.com/512MB.zip
     */
    public function download($url, $destFile)
    {
        // the destination file may be a directory. if that is the case the desired behaviour is to use the filename
        // from the url. here we strip out the filename from the url (removing the query string if necessary), and
        // append it to the directory path.
        if (is_dir($destFile)) {
            $destFile .= "/".array_values(
                array_slice(explode("/", parse_url($url, PHP_URL_PATH)), -1)
            )[0];

            // the directory path passed may or may not have been terminated with a /. if it was, we will have
            // a double / in the path. remove it.
            $destFile = preg_replace("/\/\//", "/", $destFile);
        }

        // the destination directory exists.
        // Sets lastError to 3 on failure and returns false.
        if (!@file_exists(dirname($destFile))) {
            $this->lastError["code"] = 3;
            $this->lastError["func"] = __FUNCTION__;
            $this->lastError["desc"] = "Destination directory ".dirname($destFile)." does not exist";

            return false;
        }

        // the destination directory is writeable.
        // Sets lastError to 4 on failure and returns false.
        if (!@is_writeable(dirname($destFile))) {
            $this->lastError["code"] = 4;
            $this->lastError["func"] = __FUNCTION__;
            $this->lastError["desc"] = "Destination directory ".dirname($destFile)." is not writeable";

            return false;
        }

        // for progressFilesizeTrack(), we need to know the size of the file being
        // downloaded. we do this by making a CURLOPT_NOBODY call to url to get just
        // the headers. we harvest the Content-Length from there for file size.

        // curl call with no body being downloaded
        $timeout = 5;
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout); // in seconds
        curl_setopt($ch, CURLOPT_HEADER, 1);
        curl_setopt($ch, CURLOPT_NOBODY, 1);
        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
        $res = curl_exec($ch);

        // handle any curl error
        if ($res === false) {
            $this->lastError["code"] = 7;
            $this->lastError["func"] = __FUNCTION__;
            $this->lastError["desc"] = curl_error($ch);

            return false;
        }

        // get size of file from Content-Length header as kb int
        $fileSizeKb = (int) implode(null, array_map(function ($header) {
                switch (strtolower((substr(trim($header), 0, strlen("Content-Length"))))) {
                    case "content-length" :
                        return floor(explode(" ", $header)[1]/1024);
                        break;
                    default :
                        return;
                }
            },
            explode("\n", $res)));

        curl_close($ch);

        // is sufficient disk space for the operation.
        // Sets lastError to 5 on failure and returns false.
        if (disk_free_space(dirname($destFile)) <= $fileSizeKb) {
            $this->lastError["code"] = 5;
            $this->lastError["func"] = __FUNCTION__;
            $this->lastError["desc"] = "Insufficient disk space for operation";

            return false;
        }

        // lastError is available through getLastError().

        // Process fork is attempted.
        $pid = pcntl_fork();

        // If a child process could not be spawned, die.
        if ($pid == -1) {
            die("Could not spawn child process");
        }

        // child process: show progress animation
        if ($pid) {
            $this->progressFilesizeTrack($destFile, $fileSizeKb);
        }

        // parent process: do download
        else {
            // do the download.
            if (file_put_contents($destFile, fopen($url, 'r')) === false) {
                $this->lastError["code"] = 8;
                $this->lastError["func"] = __FUNCTION__;
                $this->lastError["desc"] = "error downloading file";

                return false;
            }
        }

        // at end of copy(), SIGKILL the progress animation
        @posix_kill($pid, SIGKILL);

        // convenience message for script user
        fwrite(STDOUT, " done".PHP_EOL);

        return $destFile;
    } // download

    ##
    # Private methods

    /**
     * @brief Returns the strlen of the longest line in either the string or array passed
     *
     * Uses ANSI safe strlen() to strip out printable but unseen ANSI control chars.
     * @param $lines Mixed. Either a string of lines separated by PHP_EOL or an array of lines
     * @return Int
     */
    private function getLengthOfLongestLine($lines)
    {
        if (is_string($lines)) {
            $lines = explode(PHP_EOL, $lines);
        }

        $lengthOfLongestLine = array_reduce(
            $lines,
            function ($max, $line) {
                if ($this->strlenAnsiSafe($line) > $max) {
                    return $this->strlenAnsiSafe($line);
                }

                return $max;
            }
        );

        return $lengthOfLongestLine;
    } // getLengthOfLongestLine


    /**
     * @brief Writes to a stream, either STDOUT or STDERR, user-supplied text with optional color and formatting
     *
     * @param $text String. The string to write to the stream.
     * @param $stream Pre-defined constant. The stream to write to; either STDOUT or STDERR. Default STDOUT
     * @param $level Pre-defined constant. Optional. The PSR-2 logging level. Default NULL. Refer to the defined constants for printout or printerr.
     * @param $foreground Pre-defined constant. Optional foreground color of text. Refer to the defined constants for printout or printerr.
     * @param $background Pre-defined constant. Optional background color or font style. Refer to the defined constants for printout or printerr.
     * @param $alignment Pre-defined constant. Optional. One of LEFT, RIGHT or CENTER. default LEFT. Determines the alignment of the text.
     * @return void
     * @see Defined constants for output formatting
     */
    private function write($text, $stream = STDOUT, $level = null, $foreground = null, $background = null, $alignment = null)
    {
        // enforce that values that are not STDOUT or STDERR can never be used here.
        if ($stream != STDOUT && $stream != STDERR) {
            $stream = STDOUT;
        }

        // enforce that the level is a valid level constant. failing that, set to null
        $validLevels = unserialize(VALID_LEVELS);
        if ($level != null and !in_array($level, $validLevels)) {
            $level = null;
        }

        $textLines = explode(PHP_EOL, $text);

        $printableTextLines = [];

        // if output styling options are passed, build the required ANSI codes
        if ($foreground || $background) {
            // background colors are defined as foreground color codes plus ten. in order to allow the use of
            // the same color constant (ie RED) for both fore and background colors, we just add 10 if in the
            // background position. we only do this if the code is higher than 30 as formatting, such as BOLD,
            // is less than 30 and we don't want to increment that.
            if ($background >= BLACK) {
                $background += 10;
            }

            // since either one or both of the foreground and background can be used and as the codes must be
            // delimited with a ; and terminated with an 'm', it's easiest just to build an array of non-null
            // codes and use join() for formatting
            if ($foreground) {
                $ansiArray[] = $foreground;
            }

            if ($background) {
                $ansiArray[] = $background;
            }

            // build the output string with ANSI codes
            while (list(, $line) = each($textLines)) {
                $printableTextLines[] = $level.ESC."[".implode(";", $ansiArray)."m".$line.CLOSE_ANSI;
            }
        }

        // no output styling, build plain ouput string
        else {
            while (list(, $line) = each($textLines)) {
                $printableTextLines[] = $level.$line;
            }
        }

        // do the output to the stream with alignment padding if necessary
        while (list(, $printableTextLine) = each($printableTextLines)) {
            fwrite($stream, $this->pad($printableTextLine, $alignment).PHP_EOL);
        }

        $this->lastPrintLineCount = count($textLines);
    } // write


    /**
     * @brief Display 'waiting' animation as an ASCII art spinner
     *
     * This method contains an infinite loop and is designed to terminated with posix_kill() by a child process.
     * @param $delay. Pre-defined constant. Optional. The speed at which the animation runs. One of DELAY_SLOW, DELAY_MED, DELAY_FAST or DELAY_VERY_FAST.
     * Default DELAY_MED.
     * @note only call this method from a method that spawns a child process
     */
    private function spin($delay = DELAY_MED)
    {
        // frames of clockwise-spinning animation as chars
        $chars = array("|", "/", "-", "\\", "|", "/", "-");

        // output first char so that the initial BACKSPACE has something to erase
        fwrite(STDOUT, $chars[0]);

        // infinite loop to be killed by child process
        while (1) {
            for ($i = 0;$i<5;$i++) {
                while (list(, $char) = each($chars)) {
                    fwrite(STDOUT, BACKSPACE);  // erase previous frame
                    usleep($delay);             // wait $delay for animation speed
                    fwrite(STDOUT, $char);      // nex frame
                }
                reset($chars); // move array pointer back to start
            }
        }
        exit();
    } // spinner


    /**
     * @brief Display 'waiting' animation as a progress bar
     *
     * Progress bar is a run of # chars.
     *
     * This method contains an infinite loop and is designed to terminated with posix_kill() by a child process.
     * @param $delay. Pre-defined constant. Optional. The speed at which the animation runs. One of DELAY_SLOW, DELAY_MED, DELAY_FAST or DELAY_VERY_FAST.
     * Default DELAY_MED.
     * @note only call this method from a method that spawns a child process
     */
    private function progress($delay = DELAY_MED)
    {
        fwrite(STDOUT, "#");

        // infinite loop to be killed by child process
        while (1) {
            fwrite(STDOUT, BACKSPACE);
            usleep($delay);
            fwrite(STDOUT, "#>");
        }
        exit();
    } // progress


    /**
     * @brief Display progress update for copying files, shows percentage complete by filesize comparison
     *
     * Displayed output is in the format:
     *
     * `copying... XX.XX%`
     *
     * @param $destFile Path to the file being copied to
     * @param $targetSize Size of file being copied
     * @param $delay The speed at which the animation runs. One of DELAY_SLOW, DELAY_MED, DELAY_FAST or DELAY_VERY_FAST.
     * default is DELAY_VERY_FAST.
     * @return void
     * @note only call this method from a method that spawns a child process to do the copy work
     */
    private function progressFilesizeTrack($destFile, $targetSize, $delay = DELAY_VERY_FAST)
    {
        // loop until this child process is killed by the calling method
        while (1) {
            // PHP caches data on file sizes. In order to get realtime update on file size of $destFile, clear cache
            clearstatcache();

            // sleep for the delay. adjustable to speed up or slow down animation
            usleep($delay);

            // calculate the percentage done and format into a displayable string
            $percentDone =  number_format((@filesize($destFile)/$targetSize) * 100, 2).'%';
            $displayUpdate = "copying... $percentDone";

            // clear the previous display line
            for ($i = 0;$i<strlen($displayUpdate);$i++) {
                fwrite(STDOUT, BACKSPACE);
            }

            // we have not reached 100% done, print the new display percentage
            if ((@filesize($destFile)/$targetSize) <1) {
                fwrite(STDOUT, $displayUpdate);
            }

            // file done copying. exit loop. child process still active until killed by calling method
            else {
                fwrite(STDOUT, PHP_EOL."finishing...  ");
                fwrite(STDOUT, BACKSPACE);

                return 1;
            }
        }
    } // progressFilesizeTrack


    /**
     * @brief Builds and ouputs a formatted menu box
     *
     * @param $description String. The description that goes above the list of options
     * @param $options Array. Associative array of menu options. Key is returned on selection.
     * @param $highLightKey String. The key of the option that is currently selected.
     * @param $innerAlign Pre-defined constant. One of LEFT, RIGHT, CENTER. Alignment of text inside the box.
     * @param $outerAlign Pre-defined constant. One of LEFT, RIGHT, CENTER. Alignment of the box in the screen
     * @param $highlightColour Pre-defined constant. A colour. Used to highlight the currently selected option
     * @param $foreground Pre-defined constant. A colour. Foreground colour of the box.
     * @param $background Pre-defined constant. A colour. Background colour of the box.
     * @return void
     */
    private function printoutMenuBox($description, $options, $highLightKey, $innerAlign, $outerAlign, $highlightColour, $foreground, $background)
    {
        // the character that makes the box border
        // @todo make arg
        $boxBorderChar = "#";

        // margin inside the box before text
        // @todo make arg
        $boxMargin = 2;

        // build ANSI colour coding tags

        // default foreground, background as supplied
        $defaultAnsi = ESC."[".implode(";", [$foreground, $background+10])."m";

        // the hightlight tags as supplied, default green
        $selectedAnsi = ESC."[".implode(";", [GREEN, $background+10])."m";
        if ($highlightColour) {
            $selectedAnsi = ESC."[".implode(";", [$highlightColour, $background+10])."m";
        }

        // default prompt
        // @todo make arg
        $prompt = "(Use up and down arrow cards, hit RETURN to select)";

        // get the length of the longest key of an option. this is used for building the padding between option keys
        // and values so that values are vertically aligned, ie:
        //  k)    Value for k
        //  key2) Value for key2
        // this is only done when inner alignment is not CENTER
        $maxOptionKey = $this->getLengthOfLongestLine(array_keys($options));

        // work out the width of the longest line in menu. there are three components we have to test: the header,
        // the list of options and the prompt. we need this data so that we can properly align the text inside the
        // box.

        // length of longest line in the options list.
        // options are displayed as key + ) + padding + val so we need to build each line like that to get the lengths
        $maxOptionLength = 0;
        while (list($optionKey, $optionVal) = each($options)) {
            $optionLine = $optionKey.")".str_pad("", $maxOptionKey-$this->strlenAnsiSafe($optionKey), " ")." ".$optionVal;
            // if this line is longer than the current longest option line, it is the new longest
            if ($this->strlenAnsiSafe($optionLine) > $maxOptionLength) {
                $maxOptionLength = $this->strlenAnsiSafe($optionLine);
            }
        }
        reset($options); // reset so future loops work

        // get longest line of all content in this menu, the description, prompt and option list
        // throw the longest line counts of each component into an array and get the largest with max()
        // the result is the longest line in the entire display text, a value we use to pad inside the box
        $maxLine = max([$maxOptionLength,
            $this->getLengthOfLongestLine($description),
            $this->getLengthOfLongestLine($prompt), ]);

        // build an array of all the options with appropriate formatting

        // holds the array of all the printable lines of the options
        $optionLines = [];
        while (list($optionKey, $optionVal) = each($options)) {
            // if alignment inside the box is LEFT, we want to pad between the key and the value so the values column
            // vertically align
            if ($innerAlign == LEFT) {
                $optionLine = "  ".$optionKey.")".str_pad("", $maxOptionKey-$this->strlenAnsiSafe($optionKey), " ")." ".$optionVal;
            } else {
                $optionLine = $optionKey.") ".$optionVal;
            }

            // work out inner center justified padding
            // if we are centering inside the box, we put half the padding on the left and the other half on the right.
            // total padding is the length of the longest line in the whole display string, minus the length of this line
            if ($innerAlign == CENTER) {
                $padLeft = ceil($maxLine-$this->strlenAnsiSafe($optionLine)/2); // alternate ceil/floor to accommodate odd total padding
                $padRight = floor($maxLine-$this->strlenAnsiSafe($optionLine)/2);
            }
            // work out inner right justified padding
            // no padding right, balance on left
            elseif ($innerAlign == RIGHT) {
                $padLeft = $maxLine-$this->strlenAnsiSafe($optionLine);
                $padRight = 0;
            }
            // work out inner left justified padding. default behaviour.
            // no padding on left, balance on right.
            else {
                $padLeft = 0;
                $padRight = $maxLine-$this->strlenAnsiSafe($optionLine);
            }

            // the currently selected option, as defined by highLightKey, needs to be highlighted.
            // note that with ANSI formatting inside strings, length of the string should always be acquired with
            // strlenAnsiSafe()
            if ($optionKey == $highLightKey) {
                // format with bold and selectedAnsi
                $optionLine = BOLD_ANSI.$selectedAnsi.$optionLine.CLOSE_ANSI;
            } else {
                $optionLine = $defaultAnsi.$optionLine.CLOSE_ANSI;
            }

            // add this line to the array of option lines
            $optionLines[] =
                $defaultAnsi.// start user-supplied formatting
                $boxBorderChar.// left box border character
                str_pad("", $padLeft+$boxMargin, " ").// padding on left of option
                CLOSE_ANSI.// close formatting so it does not collide with highlighting if any
                $optionLine.// the option line, with formatting already set
                $defaultAnsi.// start user-supplied formatting
                str_pad("", $padRight+$boxMargin, " ").// padding on right of option
                $boxBorderChar.// right box border character
                CLOSE_ANSI; // close all formatting for this line
        } // while(list($optionKey, $optionVal) = each($options))...

        // build an array of all the lines in the description

        // make an array of the description string, one element per line, with a blank line padding the bottom
        // which is iterated over to apply formatting
        $descriptionExplodedLines =  array_merge(explode(PHP_EOL, $description), [""]);
        // holds the array of all the printable lines of the description
        $descriptionLines = [];
        while (list(, $line) = each($descriptionExplodedLines)) {
            // work out inner center justified padding
            // if we are centering inside the box, we put half the padding on the left and the other half on the right.
            // total padding is the length of the longest line in the whole display string, minus the length of this line
            if ($innerAlign == CENTER) {
                $padLeft = ceil($maxLine-$this->strlenAnsiSafe($line)/2); // alternate ceil/floor to accommodate odd total padding
                $padRight = floor($maxLine-$this->strlenAnsiSafe($line)/2);
            }
            // work out inner right justified padding
            // no padding right, balance on left
            elseif ($innerAlign == RIGHT) {
                $padLeft = $maxLine-$this->strlenAnsiSafe($line);
                $padRight = 0;
            }
            // work out inner left justified padding
            // no padding on left, balance on right.
            else {
                $padLeft = 0;
                $padRight = $maxLine-$this->strlenAnsiSafe($line);
            }

            $descriptionLines[] =
                $defaultAnsi.// start user-supplied formatting
                $boxBorderChar.// left box border character
                str_pad("", $padLeft+$boxMargin, " ").// padding on left of line
                $line.// the line of the description
                str_pad("", $padRight+$boxMargin, " ").// padding on right of line
                $boxBorderChar.// right box border char
                CLOSE_ANSI; // close all formatting for this line
        } // while(list(,$line) = each($descriptionExplodedLines))...

        // build an array of all the lines in the prompt

        // make an array of the prompt string, one element per line, with a blank line padding the top
        // which is iterated over to apply formatting
        $promptExplodedLines =  array_merge([""], explode(PHP_EOL, $prompt));
        // holds the array of all the printable lines of the prompt
        $promptLines = [];
        while (list(, $line) = each($promptExplodedLines)) {
            // work out inner center justified padding
            // if we are centering inside the box, we put half the padding on the left and the other half on the right.
            // total padding is the length of the longest line in the whole display string, minus the length of this line
            if ($innerAlign == CENTER) {
                $padLeft = ceil($maxLine-$this->strlenAnsiSafe($line)/2); // alternate ceil/floor to accommodate odd total padding
                $padRight = floor($maxLine-$this->strlenAnsiSafe($line)/2);
            }
            // work out inner right justified padding
            // no padding right, balance on left
            elseif ($innerAlign == RIGHT) {
                $padLeft = $maxLine-$this->strlenAnsiSafe($line);
                $padRight = 0;
            }
            // work out left justified padding
            // no padding on left, balance on right.
            else {
                $padLeft = 0;
                $padRight = $maxLine-$this->strlenAnsiSafe($line);
            }

            $promptLines[] =
                $defaultAnsi.// start user-supplied formatting
                $boxBorderChar.// left box border character
                str_pad("", $padLeft+$boxMargin, " ").// padding on left of line
                $line.// the line of the description
                str_pad("", $padRight+$boxMargin, " ").// padding on right of line
                $boxBorderChar.// right box border char
                CLOSE_ANSI; // close all formatting for this line
        } // while(list(,$line) = each($promptExplodedLines))...

        $boundaryBorderBar = $defaultAnsi.
            str_pad("", $this->strlenAnsiSafe($descriptionLines[0]), $boxBorderChar).
            CLOSE_ANSI;

        // build the array of all the lines to ouput as a string
        $returnArray = array_merge(
            [$boundaryBorderBar],   // the top bar of borderChar
            $descriptionLines,      // user-supplied description
            $optionLines,           // all the options
            $promptLines,           // the prompt line
            [$boundaryBorderBar]);  // the bottom bar of borderChar

        // apply alignment padding defined by outerAlign to each line of output
        $returnArray = array_map(function ($line, $align) {
                return $this->pad($line, $align);
            },
            $returnArray,
            array_fill(0, count($returnArray), $outerAlign));

        // write to STDOUT
        $this->printout(implode(PHP_EOL, $returnArray));
    } // printoutMenuBox


    /**
     * @brief Prepares arguments for the background() method.
     *
     * Arguments for the background() method can be provided as either NULL, a string of one arg value
     * or an array of multiple args. However, call_user_func_array() requires args as an array. This
     * method converts supplied $args to useful ones.
     * @param $args An array of args or a string of one arg or null
     * @return Array An array of arguments usable by background()
     */
    private function prepArgs($args)
    {
        if ($args == null) {
            return [];
        }

        if (is_scalar($args)) {
            return [$args];
        }

        return $args;
    } // prepArgs


    /**
     * @brief Returns the width of the terminal in columns or 0 or failure
     *
     * If there is a failure because of stty() or beause exec() has been disabled in PHP, then zero will
     * be returned. _Make sure you handle this_.
     *
     * @return Int
     * @note This method relies on an exec() call to `stty`
     * @see pad
     */
    private function getTerminalWidth()
    {
        return (int) implode("", array_map(function ($row) {
                if (substr(trim($row), 0, strlen("columns")) == "columns") {
                    return filter_var(preg_split("/ /", trim($row))[1], FILTER_VALIDATE_INT);
                }

                return;
            },
            preg_split("/;/", strtolower(exec('stty -a | grep columns')))));
    } // getTerminalWidth


    /**
     * @brief Returns the provided text with left-padding to align it (left, right or centre) in the terminal
     *
     * If the calculation of the terminal width fails or if the text is wider than the terminal, text
     * is returned unpadded, ie left-justified.
     * @param $text String. The text to centre in the terminal
     * @param $alignment Pre-defined constant. The alignment the padding should produce. One of:
     *      * LEFT
     *      * RIGHT
     *      * CENTER
     * default is CENTER.
     * @return String
     * @see getTerminalWidth
     * @see strlenAnsiSafe
     */
    private function pad($text, $alignment)
    {
        // LEFT is defined as 0 (no alignment).
        // since the alignment variable is used for division, we trap here to avoid a
        // division by zero error
        if (!$alignment) {
            return $text;
        }

        // calculate padding on left of text to create alignment.
        // note that RIGHT value is 1 and CENTER is 2 so division by $alignment works
        $leftpad = floor(($this->getTerminalWidth() - $this->strlenAnsiSafe($text))/$alignment);

        // accommodate 0 return from getTerminalWidth if it fails, or if the string to
        // centre is wider than the terminal
        if ($leftpad <= 0) {
            $leftpad = 0;
        }

        // return the padded string
        return implode("", array_fill(0,
            $leftpad,
            " ")).$text;
    } // pad


    /**
     * @brief An ANSI formatting safe strlen()
     *
     * Regular strlen() will count the printable, but invisible, chars used in ANSI escape sequences.
     * This leads to undesired results when padding for alignment.
     *
     * This method strips all ANSI control data from the provided string and returns it's strlen()
     *
     * Credit due to kenneth mccall for this.
     *
     * @param $text String. The text to get the lenght of
     * @return Int
     */
    private function strlenAnsiSafe($text)
    {
        $text = preg_replace('/\x1b(\[|\(|\))[;?0-9]*[0-9A-Za-z]/', "", $text);
        $text = preg_replace('/\x1b(\[|\(|\))[;?0-9]*[0-9A-Za-z]/', "", $text);
        $text = preg_replace('/[\x03|\x1a]/', "", $text);

        return strlen($text);
    } // strlenAnsiSafe


    /**
     * @brief Poll for user keyboard input
     *
     * Reads from STDIN and returns the char pressed on keydown. Some keydown events return
     * multiple chars; this method will return them individually.
     * @return char
     */
    private function getKeyDown()
    {
        readline_callback_handler_install("", function () {});
        while (true) {
            $r = array(STDIN);
            $w = null;
            $e = null;
            $n = stream_select($r, $w, $e, null);
            if ($n && in_array(STDIN, $r)) {
                // read the user choice from STDIN
                $userChoice = stream_get_contents(STDIN, 1);

                break;
            }
        }

        return $userChoice;
    } // getKeyDown
} //Clibelt
